# AI 활용 개발 기록: 구독 가성비 트래커

> 이 문서는 Claude Code를 활용하여 4일 만에 풀스택 웹 애플리케이션을 개발한 경험을 기록합니다.

## 프로젝트 개요

| 항목 | 내용 |
|------|------|
| 프로젝트명 | 구독 가성비 트래커 (Subscription Value Tracker) |
| 개발 기간 | 2026년 1월 8일 ~ 11일 (4일) |
| 총 커밋 | 35개 |
| 사용 AI 도구 | Claude Code (CLI) |
| MCP 연동 | TaskManager, GitHub MCP |
| 기술 스택 | Java 21, Spring Boot 4.x, Thymeleaf, HTMX, Tailwind CSS |

---

## 1. AI 활용 작업 목록

### 1.1 프로젝트 설계 및 문서화

| 작업 | AI 활용 방식 | 결과물 |
|------|-------------|--------|
| PRD 작성 | 아이디어 설명 → 구조화된 PRD 생성 | `PRD.md` |
| 기술 스펙 설계 | 요구사항 기반 데이터 모델, API 설계 | `PROJECT_SPEC.md` |
| 개발 문서 | ERD, 플로우차트 자동 생성 | `DEVELOPMENT.md` |
| 코딩 가이드 | 프로젝트 컨벤션 정의 | `CLAUDE.md` |

### 1.2 백엔드 개발

| 작업 | AI 활용 방식 |
|------|-------------|
| Spring Boot 프로젝트 구조 설계 | DDD 스타일 패키지 구조 제안 |
| Entity 설계 | 요구사항 → JPA Entity + 관계 매핑 |
| Repository/Service 구현 | CRUD + 비즈니스 로직 구현 |
| Controller 구현 | REST API + Thymeleaf 뷰 컨트롤러 |
| 복잡한 계산 로직 | 회당 비용 계산, 손익분기점 계산 |

### 1.3 프론트엔드 개발

| 작업 | AI 활용 방식 |
|------|-------------|
| Thymeleaf 템플릿 | 레이아웃, 컴포넌트 구조화 |
| Tailwind CSS 스타일링 | 다크모드, 반응형 UI |
| HTMX 인터랙션 | 출석 체크 시 부분 업데이트 |
| Chart.js 차트 | 통계 시각화 구현 |
| 캘린더 UI | 월간 달력 + 색상 코딩 |

### 1.4 테스트 코드 작성

| 작업 | AI 활용 방식 |
|------|-------------|
| Service 단위 테스트 | JUnit 5 + Mockito |
| Controller 테스트 | MockMvc 테스트 |
| 유틸리티 테스트 | EmojiMapper, UserIdentifier 테스트 |

### 1.5 버그 수정 및 리팩토링

| 작업 | AI 활용 방식 |
|------|-------------|
| Thymeleaf 보안 이슈 | onclick 핸들러 XSS 취약점 수정 |
| 데이터 직렬화 문제 | HTML data attribute 방식으로 변경 |
| 비용 계산 로직 수정 | 월별 → 전체 기간 기준으로 변경 |

---

## 2. 프롬프트 예시

### 2.1 프로젝트 초기 설정

```
나는 구독 서비스의 가성비를 계산하는 웹앱을 만들고 싶어.
핵심 컨셉은 "출석할수록 금액이 내려가는 걸 눈으로 보면서 뿌듯함 느끼기"야.

기술 스택:
- Java 21 + Spring Boot
- Thymeleaf + HTMX (프론트엔드 빌드 없이)
- H2 (개발) / MySQL (운영)
- Tailwind CSS

PRD를 작성해줘.
```

### 2.2 기능 구현 요청

```
캘린더 뷰를 구현해줘.
- 월간 달력 형태
- 각 날짜에 출석한 구독 서비스의 이모지와 회당 비용 표시
- 색상: 초록(가성비 좋음) / 노랑(보통) / 빨강(경고)
- 날짜 클릭하면 해당 날짜에 출석 체크할 수 있는 모달
```

### 2.3 버그 수정 요청

```
캘린더에서 회당 비용이 이상하게 표시돼.
현재: 이번 달 사용 횟수로 나눔
원하는 것: 구독 시작부터 현재까지 총 사용 횟수로 나눔

예: 12개월 구독 (총 180,000원), 총 10회 사용 → 18,000원/회
```

### 2.4 리팩토링 요청

```
출석 체크할 때 페이지 전체가 새로고침 되는데,
HTMX를 써서 캘린더 영역만 부분 업데이트 되도록 바꿔줘.
```

---

## 3. AI 활용의 장점

### 3.1 생산성 향상

| 항목 | AI 없이 (추정) | AI 활용 | 단축률 |
|------|---------------|---------|--------|
| PRD/스펙 문서 | 2-3일 | 2-3시간 | ~90% |
| Entity + Repository | 4-6시간 | 30분 | ~90% |
| CRUD API + 화면 | 2-3일 | 4-6시간 | ~70% |
| 캘린더 UI | 1-2일 | 2-3시간 | ~80% |
| 차트 기능 | 4-6시간 | 1-2시간 | ~70% |
| **전체 프로젝트** | **3-4주** | **4일** | **~85%** |

### 3.2 코드 품질

- **일관된 코드 스타일**: 프로젝트 전반에 동일한 패턴 적용
- **모범 사례 적용**: Spring Boot, JPA 베스트 프랙티스 자동 적용
- **보안 이슈 감지**: XSS 취약점 등 보안 문제 발견 및 수정
- **테스트 코드 작성**: 단위 테스트 자동 생성

### 3.3 학습 효과

- 새로운 기술(HTMX) 빠르게 적용
- Tailwind CSS 클래스 활용법 습득
- Spring Boot 4.x 새 기능 학습

---

## 4. AI 활용의 한계 및 주의점

### 4.1 맥락 이해의 한계

```
문제: 비용 계산 로직을 "이번 달 사용 횟수"로 구현
원인: 초기 PRD의 표현이 모호했음
해결: 구체적인 예시와 함께 요구사항 재설명
```

### 4.2 UI/UX 감각

- AI는 기능 구현에 강하지만, 미적 감각은 제한적
- 색상 선택, 레이아웃 배치 등은 직접 조정 필요
- 와이어프레임 등 시각적 레퍼런스 제공하면 효과적

### 4.3 비즈니스 로직 검증 필요

```java
// AI가 생성한 코드
public BigDecimal calculateCostPerUse() {
    if (totalUsageCount == 0) return totalAmount; // 0으로 나누기 방지
    return totalAmount.divide(BigDecimal.valueOf(totalUsageCount),
                              0, RoundingMode.HALF_UP);
}

// 검토 포인트
// - 0회 사용 시 전체 금액 반환이 맞는지?
// - 반올림 방식이 적절한지?
```

### 4.4 지속적인 커뮤니케이션

- 한 번에 완벽한 코드를 기대하지 말 것
- 반복적인 피드백과 수정 요청 필요
- 작은 단위로 요청하고 검증하는 것이 효과적

---

## 5. 효과적인 AI 활용 팁

### 5.1 명확한 컨텍스트 제공

```
좋은 예:
"Spring Boot 4.x + Thymeleaf + HTMX 환경에서
출석 체크 버튼 클릭 시 캘린더 영역만 부분 업데이트"

나쁜 예:
"출석 체크 기능 만들어줘"
```

### 5.2 CLAUDE.md 활용

프로젝트 루트에 `CLAUDE.md` 파일을 두면 Claude Code가 자동으로 읽어서 컨텍스트로 활용합니다:

```markdown
# CLAUDE.md
- 기술 스택 정보
- 프로젝트 구조
- 코딩 컨벤션
- 테스트 규칙
- Git 워크플로우
```

### 5.3 단계별 개발

```
1단계: 엔티티 설계 → 검토 → 확정
2단계: Repository + Service → 검토 → 확정
3단계: Controller + View → 검토 → 확정
4단계: 테스트 코드 → 검토 → 확정
```

### 5.4 QA 프로세스

기능 개발 후 AI에게 QA 테스트 항목을 요청:

```
개발 완료 후 확인해야 할 QA 항목을 정리해줘.
```

결과를 `QA_RESULTS.md`에 기록하여 품질 관리.

### 5.5 MCP (Model Context Protocol) 활용

Claude Code는 MCP를 통해 외부 도구와 연동할 수 있습니다. 이 프로젝트에서 활용한 MCP 도구:

| MCP 도구 | 용도 |
|----------|------|
| **TaskManager** | 복잡한 작업을 하위 태스크로 분해하여 관리. 진행 상황 추적 및 체크리스트 관리에 활용 |
| **GitHub MCP** | PR 생성, 이슈 관리, 커밋 히스토리 조회 등 GitHub 작업을 Claude Code 내에서 직접 수행 |

MCP 설정 방법:
```bash
# Claude Code 설정에서 MCP 서버 추가
claude mcp add taskmanager
claude mcp add github
```

---

## 6. 결론

### 6.1 AI 활용 개발의 핵심

1. **AI는 도구**: 최종 결정과 검증은 개발자의 몫
2. **명확한 요구사항**: 구체적인 예시와 컨텍스트 제공
3. **반복적 개선**: 한 번에 완벽한 코드를 기대하지 말 것
4. **문서화**: CLAUDE.md 등으로 프로젝트 컨텍스트 유지

### 6.2 이 프로젝트에서 배운 점

- 4일 만에 풀스택 웹앱 MVP 완성 가능
- AI와의 협업은 "페어 프로그래밍"에 가까움
- 코드 리뷰와 테스트의 중요성은 여전함
- 비즈니스 로직 이해와 검증은 개발자의 역할

---

## 7. 향후 계획: Ralph Wiggum 자율 루프 활용

### 7.1 Ralph Wiggum이란?

[Ralph Wiggum](https://github.com/anthropics/claude-code/tree/main/plugins/ralph-wiggum)은 Claude Code의 공식 플러그인으로, AI가 **자율적으로 반복 작업**을 수행하게 하는 기법입니다.

```
작업 시작 → Claude 작업 → 종료 시도 → Stop hook이 차단 → 같은 프롬프트 재주입 → 반복
```

심슨의 캐릭터 이름에서 유래했으며, 2025년 말 Anthropic이 공식 채택했습니다.

### 7.2 적용 예정 작업

| 작업 | 목표 | 예상 iteration |
|------|------|----------------|
| 테스트 커버리지 확대 | 80% 이상 달성 | 10-20 |
| 코드 리팩토링 | 중복 코드 제거, 패턴 통일 | 10-15 |
| 성능 최적화 | N+1 쿼리 해결, 캐싱 적용 | 5-10 |
| 새 기능 추가 | (추후 결정) | TBD |

### 7.3 사용 계획

```bash
# 플러그인 설치
claude plugins install ralph-wiggum

# 테스트 커버리지 확대 예시
/ralph-loop "테스트 커버리지를 80% 이상으로 올려줘.
현재 테스트가 없는 Service, Controller를 찾아서
JUnit 5 + Mockito로 테스트 작성해줘." \
--completion-promise "COVERAGE_COMPLETE" \
--max-iterations 20
```

### 7.4 비용 및 리스크 관리

| 항목 | 전략 |
|------|------|
| 토큰 비용 | `--max-iterations` 제한 (초기 10-20) |
| 품질 검증 | 매 iteration 후 diff 리뷰 |
| 롤백 계획 | 작업 전 브랜치 생성, 실패 시 reset |

### 7.5 결과 기록 (예정)

> 이 섹션은 Ralph Wiggum 활용 후 실제 결과로 업데이트 예정

| 날짜 | 작업 | Iterations | 소요 시간 | 비용 | 결과 |
|------|------|------------|----------|------|------|
| - | - | - | - | - | - |

**기대 효과:**
- 반복적인 작업의 자동화
- 개발자는 검증과 의사결정에 집중
- AI 자율 에이전트 운영 경험 축적

---

## 부록: 프로젝트 통계

```
개발 기간: 4일 (2026-01-08 ~ 2026-01-11)
총 커밋: 35개
코드 라인: ~3,000+ (추정)

파일 구성:
- Java 소스: ~20개
- Thymeleaf 템플릿: ~15개
- 테스트 코드: ~10개
- 문서: 7개 (.md 파일)
```

---

*이 문서는 Claude Code를 활용하여 작성되었습니다.*
